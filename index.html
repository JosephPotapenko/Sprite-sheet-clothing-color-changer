<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sprite Color Shifter — Palette Extract & Replace</title>
<link rel="stylesheet" href="style.css">
<style>
/* Add blue glow for grouped swatches */
.swatch.grouped {
  box-shadow: 0 0 0 3px #7fdfff, 0 0 12px #7fdfff;
  border: 2px solid #7fdfff !important;
  z-index: 2;
}

/* Rainbow gradient for hue slider input itself */
#hueSlider {
  width: 100%;
  height: 18px;
  border-radius: 8px;
  /* Initial background at lightness 50 */
  background: linear-gradient(90deg, #800080 0%, #8000ff 10%, #0080ff 20%, #00ffff 30%, #00ff80 40%, #80ff00 50%, #ffff00 60%, #ff8000 70%, #ff0080 80%, #ff00ff 90%, #800080 100%);
  -webkit-appearance: none;
  appearance: none;
  outline: none;
}
#hueSlider::-webkit-slider-thumb, #lightnessSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #7fdfff;
  box-shadow: 0 0 6px #7fdfff;
  cursor: pointer;
  transition: background 0.2s;
}
#hueSlider::-moz-range-thumb, #lightnessSlider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #7fdfff;
  box-shadow: 0 0 6px #7fdfff;
  cursor: pointer;
  transition: background 0.2s;
}
#hueSlider::-ms-thumb, #lightnessSlider::-ms-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #7fdfff;
  box-shadow: 0 0 6px #7fdfff;
  cursor: pointer;
  transition: background 0.2s;
}
#hueSlider::-webkit-slider-runnable-track, #lightnessSlider::-webkit-slider-runnable-track {
  height: 18px;
  border-radius: 8px;
  background: transparent;
}
#hueSlider::-ms-fill-lower, #hueSlider::-ms-fill-upper,
#lightnessSlider::-ms-fill-lower, #lightnessSlider::-ms-fill-upper {
  background: transparent;
}
#hueSlider:focus, #lightnessSlider:focus {
  outline: none;
}
/* Lightness slider gradient will be set dynamically via JS */
#lightnessSlider {
  width: 100%;
  height: 18px;
  border-radius: 8px;
  background: linear-gradient(90deg, #000, #fff);
  -webkit-appearance: none;
  appearance: none;
  outline: none;
}
/* Slider value display */
.slider-value {
  min-width: 32px;
  text-align: right;
  font-size: 13px;
  color: #7fdfff;
  font-weight: bold;
  margin-left: 6px;
  margin-right: 2px;
  user-select: none;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.swatch-tab {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  margin-top: 2px;
  background: #222;
  border-radius: 6px;
  padding: 4px 2px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.12);
}
.swatch-tab input[type="color"] {
  width: 22px;
  height: 22px;
  border: none;
  border-radius: 4px;
  margin-bottom: 2px;
  cursor: pointer;
}
.swatch-tab .swatch-lightness-slider {
  width: 60px;
  height: 14px;
  border-radius: 6px;
  margin-bottom: 2px;
  -webkit-appearance: none;
  appearance: none;
  outline: none;
  background: linear-gradient(90deg, #000, #fff);
}
.swatch-tab .swatch-lightness-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #7fdfff;
  box-shadow: 0 0 4px #7fdfff;
  cursor: pointer;
}
.swatch-tab .swatch-lightness-slider::-moz-range-thumb {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #7fdfff;
  box-shadow: 0 0 4px #7fdfff;
  cursor: pointer;
}
.swatch-tab .swatch-lightness-slider::-ms-thumb {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #7fdfff;
  box-shadow: 0 0 4px #7fdfff;
  cursor: pointer;
}
.swatch-tab .swatch-lightness-slider::-webkit-slider-runnable-track {
  height: 14px;
  border-radius: 6px;
  background: transparent;
}
.swatch-tab .swatch-lightness-slider:focus {
  outline: none;
}
.swatch-tab .swatch-lightness-value {
  font-size: 11px;
  color: #7fdfff;
  margin-left: 2px;
  margin-right: 2px;
  min-width: 24px;
  text-align: right;
}
.swatch-tab .swatch-arrow {
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: none;
  background: #222;
  color: #7fdfff;
  font-size: 13px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin: 0 1px;
  transition: background 0.2s;
}
.swatch-tab .swatch-arrow:hover {
  background: #333;
}
.swatch {
  position: relative;
}
.swatch input[type="color"] {
  opacity: 0;
  pointer-events: none;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  transition: opacity 0.18s;
  z-index: 3;
}
.swatch:hover input[type="color"] {
  opacity: 1;
  pointer-events: auto;
}
.panel {
  /* Keep panel fixed to the right edge as user requested */
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 600px;
  min-width: 0;
  max-width: 130vw;
  height: 200vh;
  overflow-y: auto;
  background: var(--glass, #181c22e6);
  box-shadow: -2px 0 16px rgba(0,0,0,0.12);
  z-index: 10;
  padding: 24px 18px 18px 18px;
  display: flex;
  flex-direction: column;
}
.app {
  /* Make space for fixed panel on the right */
  display: flex;
  flex-direction: row;
  min-height: 100vh;
  width: 100vw;
  box-sizing: border-box;
}
.left {
  flex: 1 1 0;
  min-width: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
  /* Prevent content under panel */
  margin-right: 600px;
}
.canvas-container {
  /* Center the image container horizontally and vertically in the available space */
  width: 100%;
  max-width: calc(90vw - 600px);
  box-sizing: border-box;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 400px;
  overflow: hidden;
  margin-left: 0px;
}
#canvasViewport {
  /* Center the canvas itself */
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
}
/* Lighten/darken blend mode */
.lighten-only {
  image-rendering: pixelated;
  mix-blend-mode: lighten;
}
.darken-only {
  image-rendering: pixelated;
  mix-blend-mode: multiply;
}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="topbar">
      <div class="brand">Sprite Color Shifter</div>
      <div class="controls-row">
        <input id="fileInput" type="file" accept="image/*" />
        <button id="downloadImage" class="btn">Download PNG</button>
        <button id="resetAll" class="btn">Reset</button>
        <button id="resetZoomPan" class="btn">Center Image</button>
        <button id="clearSelection" class="btn">Clear Selection</button>
      </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
      <div id="canvasViewport">
        <canvas id="canvas"></canvas>
      </div>
      <canvas class="image-highlight-overlay" style="display:none"></canvas>
      <!-- Removed grid tools -->
    </div>

    <div style="display:flex;gap:12px;margin-top:8px;">
      <div style="flex:1" class="small">
        <div>Zoom & Pan: wheel to zoom, drag to pan, double-click to reset. Ctrl/Cmd + wheel also adjusts zoom.</div>
      </div>
      <!-- Removed grid size controls -->
    </div>
  </div>

  <aside class="panel">
    <h3>Palette & Tools</h3>

    <div class="file-input">
      <div>
        <div class="small">Extracted palette</div>
        <!-- Change swatches to 5 columns -->
        <div class="swatches" id="colorList" aria-label="extracted palette" style="display:grid;grid-template-columns:repeat(12,1fr);gap:6px;max-height:320px;overflow:auto;padding:6px;background:var(--glass);border-radius:8px"></div>
      </div>
    </div>

    <div style="margin-top:8px" class="small">Click a swatch → highlight. Ctrl/Cmd+click multiple → group/select. Selected group affected by sliders.</div>

    <div style="margin-top:10px">
      <div class="slider-row">
        <!-- hue arrows + slider -->
        <button id="hueLeft" class="slider-arrow" title="Decrease hue">◀</button>
        <input id="hueSlider" type="range" min="0" max="360" value="180" style="flex:1;">
        <button id="hueRight" class="slider-arrow" title="Increase hue">▶</button>
        <span id="hueValue" class="slider-value">180°</span>
      </div>
      <div class="small">Hue (degrees). Slider shows the absolute hue applied to selected colors.</div>
    </div>
    <div style="margin-top:8px">
      <div class="slider-row">
        <!-- lightness arrows + slider -->
        <button id="lightLeft" class="slider-arrow" title="Decrease lightness">◀</button>
        <input id="lightnessSlider" type="range" min="0" max="100" value="50" style="flex:1;">
        <button id="lightRight" class="slider-arrow" title="Increase lightness">▶</button>
        <span id="lightValue" class="slider-value">50%</span>
      </div>
      <div class="small">Lightness (%) — 0% black, 100% white. Slider shows group's average lightness.</div>
    </div>

    <div style="margin-top:10px;display:flex;gap:6px;align-items:center">
      <button id="applyHue" class="btn">Apply to Selected</button>
      <button id="undoColors" class="btn">Undo</button>
      <button id="redoColors" class="btn">Redo</button>
    </div>

    <div style="margin-top:12px">
      <div class="small">Merge similar colors threshold: <span id="mergeThresholdValue">5</span>%</div>
      <input id="mergeThresholdSlider" type="range" min="0" max="30" value="5">
      <div style="margin-top:8px;display:flex;gap:6px">
        <button id="applyMerge" class="btn">Merge</button>
        <button id="undoMerge" class="btn">Undo Merge</button>
      </div>
    </div>

    <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">
  </aside>
</div>

<script>
/* -------------------------
  Utilities (HSL / RGB / HEX)
   * Based on the logic in your uploaded file
   * Maintains same conversion functions
-------------------------*/
function hexToRgb(hex) { if (hex[0]==="#") hex = hex.slice(1); const bigint = parseInt(hex,16); return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 }; }
function rgbToHex(r,g,b){ return "#" + [r,g,b].map(x => x.toString(16).padStart(2,"0")).join(""); }
function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h=0,s=0,l=(max+min)/2; if(max!==min){ const d=max-min; s = l>0.5 ? d/(2-max-min) : d/(max+min); switch(max){ case r: h = (g-b)/d + (g<b?6:0); break; case g: h = (b-r)/d + 2; break; case b: h = (r-g)/d + 4; break; } h /= 6; } return {h,s,l}; }
function hslToRgb(h,s,l){ let r,g,b; if (s===0) { r=g=b=l; } else { const hue2rgb = (p,q,t) => { if (t<0) t+=1; if (t>1) t-=1; if (t<1/6) return p+(q-p)*6*t; if (t<1/2) return q; if (t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }; const q = l < 0.5 ? l * (1 + s) : l + s - l*s; const p = 2*l - q; r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3); } return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) }; }

/* -------------------------
  DOM references
-------------------------*/
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha:true });
const colorList = document.getElementById('colorList');
const canvasViewport = document.getElementById('canvasViewport');
const canvasContainer = document.getElementById('canvasContainer');

const hueSliderEl = document.getElementById('hueSlider');
const hueValue = document.getElementById('hueValue');
const lightSliderEl = document.getElementById('lightnessSlider');
const lightValue = document.getElementById('lightValue');

/* DOM refs for new arrows */
const hueLeft = document.getElementById('hueLeft');
const hueRight = document.getElementById('hueRight');
const lightLeft = document.getElementById('lightLeft');
const lightRight = document.getElementById('lightRight');

const lightnessSlider = document.getElementById('lightnessSlider') || (() => { // create in-memory fallback if not present
  const el = document.createElement('input'); el.type='range'; return el;
})();
const applyHueBtn = document.getElementById('applyHue');
const downloadButton = document.getElementById('downloadImage');
const resetAllBtn = document.getElementById('resetAll');
const mergeSlider = document.getElementById('mergeThresholdSlider');
const mergeValue = document.getElementById('mergeThresholdValue');
const applyMergeBtn = document.getElementById('applyMerge');
const undoMergeBtn = document.getElementById('undoMerge');
const undoColors = document.getElementById('undoColors');
const redoColors = document.getElementById('redoColors');
/* -------------------------
  Internal state
-------------------------*/
let originalImageData = null;       // ImageData of original loaded image (RGBA)
let originalLoadedImageData = null;   // pristine first-loaded pixels
let originalPalette = null;           // pristine palette array
let originalClusters = null;          // pristine clusters mapping
let originalCanvasWidth = 0, originalCanvasHeight = 0;
let displayedWidth = 0, displayedHeight = 0;
let extractedPalette = [];         // array of [r,g,b]
let clusters = null;               // Uint16Array mapping pixel -> palette index
let highlightedColorIndex = -1;
let selectedGroup = new Set();     // indexes of palette colors that are selected (Ctrl+click grouping)
let doRecolor = true;

let paletteHistory = [];
let clustersHistory = [];
let historyIndex = -1;
const MAX_HISTORY = 60;

/* Zoom/pan */
let zoomLevel = 1, panX = 0, panY = 0;
let isDragging = false, lastMouseX=0, lastMouseY=0;
const MIN_ZOOM = 0.1, MAX_ZOOM = 10;

/* sampling cap for huge images (keeps performance) */
const MAX_SAMPLES = 20000;
const TARGET_PER_PALETTE = 75;

/* -------------------------
  K-means-ish diverse extraction (from uploaded file)
-------------------------*/
function extractDiverseColors(data, k){
  // Improved: sample pixels evenly, skip transparent, and avoid duplicate colors
  const samples = [];
  const seen = new Set();
  const step = Math.max(1, Math.floor((data.length/4) / Math.max(3000, k*10)));
  for (let i=0;i<data.length;i+=4*step){
    const a = data[i+3];
    if (a < 200) continue;
    const r = data[i], g = data[i+1], b = data[i+2];
    const key = `${r},${g},${b}`;
    if (!seen.has(key)) {
      samples.push([r,g,b]);
      seen.add(key);
    }
  }
  // If not enough samples, fallback to all pixels
  if (samples.length < k) {
    for (let i=0;i<data.length;i+=4){
      const a = data[i+3];
      if (a < 200) continue;
      const r = data[i], g = data[i+1], b = data[i+2];
      const key = `${r},${g},${b}`;
      if (!seen.has(key)) {
        samples.push([r,g,b]);
        seen.add(key);
      }
      if (samples.length >= k) break;
    }
  }
  // K-means clustering (simple, fixed iterations)
  if (samples.length === 0) return [];
  let centroids = samples.slice(0, Math.min(k, samples.length)).map(s => s.slice());
  const iterations = 6;
  for (let iter=0; iter<iterations; iter++){
    const groups = Array.from({length:centroids.length}, ()=>[]);
    for (const p of samples){
      let idx=0, bestD=Infinity;
      for (let i=0;i<centroids.length;i++){
        const c = centroids[i];
        const d = (c[0]-p[0])**2 + (c[1]-p[1])**2 + (c[2]-p[2])**2;
        if (d < bestD) { bestD=d; idx=i; }
      }
      groups[idx].push(p);
    }
    centroids = centroids.map((c,i)=>{
      const g = groups[i];
      if (!g || g.length===0) return c;
      const sum = g.reduce((acc,v)=>[acc[0]+v[0],acc[1]+v[1],acc[2]+v[2]],[0,0,0]);
      return [ Math.round(sum[0]/g.length), Math.round(sum[1]/g.length), Math.round(sum[2]/g.length) ];
    });
  }
  // Remove duplicates and sort by frequency (optional)
  const uniq = Array.from(new Set(centroids.map(c => rgbToHex(c[0],c[1],c[2]))));
  return uniq.map(h=>{
    const {r,g,b} = hexToRgb(h);
    return [r,g,b];
  });
}

function nearestPaletteIndex(p, palette){
  let best=0, bestD=Infinity;
  for (let i=0;i<palette.length;i++){
    const c=palette[i];
    const d=(c[0]-p[0])**2 + (c[1]-p[1])**2 + (c[2]-p[2])**2;
    if (d < bestD){ bestD = d; best = i; }
  }
  return best;
}

function assignClusters(data, palette){
  const len = data.length/4;
  const arr = new Uint16Array(len);
  for (let i=0,pid=0;i<data.length;i+=4,pid++){
    arr[pid] = nearestPaletteIndex([data[i],data[i+1],data[i+2]], palette);
  }
  return arr;
}

/* -------------------------
  Drawing / highlights / overlay logic
   - uses overlay canvas for fast highlighting scaled to viewport
-------------------------*/
let highlightOverlay = null;

function createHighlightOverlay(){
  if (!canvas.width || !canvas.height) return null;
  const overlay = document.createElement('canvas');
  const canvasRect = canvas.getBoundingClientRect();
  overlay.width = Math.round(canvasRect.width);
  overlay.height = Math.round(canvasRect.height);
  overlay.style.position = 'absolute';
  overlay.style.top = '50%'; overlay.style.left='50%';
  overlay.style.transform='translate(-50%,-50%)';
  overlay.style.width = overlay.width + 'px';
  overlay.style.height = overlay.height + 'px';
  overlay.style.pointerEvents='none';
  overlay.style.zIndex='12';
  overlay.className='image-highlight-overlay';
  canvasContainer.appendChild(overlay);
  return overlay;
}

function updateOverlayPosition(){
  if (!highlightOverlay) return;
  const canvasRect = canvas.getBoundingClientRect();
  const overlayWidth = Math.round(canvasRect.width);
  const overlayHeight = Math.round(canvasRect.height);
  highlightOverlay.width = overlayWidth;
  highlightOverlay.height = overlayHeight;
  highlightOverlay.style.width = overlayWidth + 'px';
  highlightOverlay.style.height = overlayHeight + 'px';
  // apply same viewport transform to overlay
  const viewportTransform = canvasViewport.style.transform || '';
  highlightOverlay.style.transform = `translate(-50%,-50%) ${viewportTransform}`;
  if (highlightedColorIndex >= 0) redrawHighlightContent(highlightedColorIndex);
}

function redrawHighlightContent(colorIndex){
  if (!highlightOverlay || !originalImageData || !clusters) return;
  const overlayCtx = highlightOverlay.getContext('2d');
  const w = originalImageData.width, h = originalImageData.height;
  const imageData = new ImageData(new Uint8ClampedArray(w*h*4), w, h);
  for (let i=0,pid=0;i<originalImageData.data.length;i+=4,pid++){
    if (clusters[pid] === colorIndex){
      imageData.data[i] = 255; imageData.data[i+1] = 255; imageData.data[i+2] = 255; imageData.data[i+3] = 120;
    } else {
      imageData.data[i+3] = 0;
    }
  }
  const temp = document.createElement('canvas'); temp.width = w; temp.height = h;
  temp.getContext('2d').putImageData(imageData,0,0);
  overlayCtx.clearRect(0,0,highlightOverlay.width, highlightOverlay.height);
  overlayCtx.imageSmoothingEnabled = false;
  overlayCtx.drawImage(temp, 0, 0, highlightOverlay.width, highlightOverlay.height);
}

function clearHighlight(){
  if (highlightOverlay){ highlightOverlay.remove(); highlightOverlay=null; }
  highlightedColorIndex = -1;
  document.querySelectorAll('.swatch.highlighted').forEach(s=>s.classList.remove('highlighted'));
}

function highlightColorInImage(colorIndex){
  if (!originalImageData || !clusters || colorIndex < 0) { clearHighlight(); return; }
  if (highlightOverlay) { highlightOverlay.remove(); highlightOverlay = null; }
  highlightOverlay = createHighlightOverlay();
  if (!highlightOverlay) return;
  redrawHighlightContent(colorIndex);
  highlightedColorIndex = colorIndex;
  updateOverlayPosition();
}

/* -------------------------
  Palette UI rendering & interactions
-------------------------*/
function renderExtractedPalette(){
  colorList.innerHTML = '';
  extractedPalette.forEach((c,i)=>{
    const hex = rgbToHex(c[0],c[1],c[2]);
    const el = document.createElement('div');
    el.className = 'swatch';
    el.style.background = hex;
    el.title = `${hex} — idx ${i}`;
    const idx = document.createElement('div'); idx.className='idx'; idx.textContent = i;
    el.appendChild(idx);

    // Only show color picker for this swatch (hidden until hover)
    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    colorInput.value = hex;
    colorInput.title = 'Change color';
    colorInput.style.width = '22px';
    colorInput.style.height = '22px';
    colorInput.style.border = 'none';
    colorInput.style.borderRadius = '4px';
    colorInput.style.marginTop = '2px';
    colorInput.style.cursor = 'pointer';
    // All positioning/visibility handled by CSS above

    // Show color picker on hover or click, keep open until blur or another swatch is clicked
    let pickerOpen = false;
    el.addEventListener('mouseenter', () => {
      if (!pickerOpen) colorInput.style.opacity = '1';
      colorInput.style.pointerEvents = 'auto';
    });
    el.addEventListener('mouseleave', () => {
      if (!pickerOpen) {
        colorInput.style.opacity = '';
        colorInput.style.pointerEvents = '';
      }
    });
    el.addEventListener('click', (ev) => {
      // Open color picker and keep it open until blur or another swatch is clicked
      pickerOpen = true;
      colorInput.style.opacity = '1';
      colorInput.style.pointerEvents = 'auto';
      colorInput.focus();
      colorInput.click();
      // Deselect other open pickers
      document.querySelectorAll('.swatch input[type="color"]').forEach(input => {
        if (input !== colorInput) {
          input.style.opacity = '';
          input.style.pointerEvents = '';
          input.blur();
          input.parentElement.pickerOpen = false;
        }
      });
      // ...existing group/select logic...
      if (ev.ctrlKey || ev.metaKey){
        if (selectedGroup.has(i)){
          selectedGroup.delete(i);
        } else {
          selectedGroup.add(i);
        }
        document.querySelectorAll('.swatch.grouped').forEach(s=>s.classList.remove('grouped'));
        Array.from(selectedGroup).forEach(idx=>{
          const swatch = colorList.children[idx];
          if (swatch) swatch.classList.add('grouped');
        });
        updateStatus();
        updateSlidersFromSelectedGroup();    // <-- newly added
      } else {
        if (highlightedColorIndex === i){
          clearHighlight();
        } else {
          clearHighlight();
          el.classList.add('highlighted');
          highlightColorInImage(i);
        }
      }
    });
    colorInput.addEventListener('blur', () => {
      pickerOpen = false;
      colorInput.style.opacity = '';
      colorInput.style.pointerEvents = '';
    });
    colorInput.addEventListener('input', (e) => {
      const {r,g,b} = hexToRgb(e.target.value);
      saveToHistory();
      extractedPalette[i] = [r,g,b];
      applyPaletteToCanvas();
      renderExtractedPalette();
      // Keep picker open after update
      setTimeout(() => {
        colorInput.focus();
      }, 0);
    });
    el.appendChild(colorInput);

    // ...existing contextmenu logic...
    el.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault();
      const input = document.createElement('input'); input.type='color';
      input.value = hex; input.style.position='fixed'; input.style.left=ev.clientX+'px'; input.style.top=ev.clientY+'px';
      input.addEventListener('input',(e)=>{
        const newHex = e.target.value; const {r,g,b} = hexToRgb(newHex);
        saveToHistory();
        extractedPalette[i] = [r,g,b];
        applyPaletteToCanvas();
        renderExtractedPalette();
      });
      document.body.appendChild(input); input.click();
      setTimeout(()=>{ input.remove(); }, 3000);
    });
    if (selectedGroup.has(i)) el.classList.add('grouped');
    colorList.appendChild(el);
  });
}

function updateStatus(){
  const paletteCount = extractedPalette.length;
  const selCount = selectedGroup.size;
  // statusText.textContent = `Palette: ${paletteCount} colors — Selected group: ${selCount}`;
}

/* -------------------------
  History (undo/redo)
-------------------------*/
function saveToHistory(){
  // trim redo
  paletteHistory = paletteHistory.slice(0, historyIndex+1);
  clustersHistory = clustersHistory.slice(0, historyIndex+1);
  paletteHistory.push(extractedPalette.map(c=>[...c]));
  clustersHistory.push(clusters ? new Uint16Array(clusters) : null);
  if (paletteHistory.length > MAX_HISTORY){ paletteHistory.shift(); clustersHistory.shift(); }
  historyIndex = paletteHistory.length - 1;
  updateUndoRedoButtons();
}

function undo(steps=1){
  const target = Math.max(0, historyIndex - steps);
  if (target < historyIndex && paletteHistory[target]){
    historyIndex = target;
    extractedPalette = paletteHistory[historyIndex].map(c=>[...c]);
    clusters = clustersHistory[historyIndex] ? new Uint16Array(clustersHistory[historyIndex]) : (originalImageData ? assignClusters(originalImageData.data, extractedPalette) : null);
    applyPaletteToCanvas();
    renderExtractedPalette(); clearHighlight(); updateUndoRedoButtons();
  }
}
function redo(steps=1){
  const target = Math.min(paletteHistory.length-1, historyIndex + steps);
  if (target > historyIndex && paletteHistory[target]){
    historyIndex = target;
    extractedPalette = paletteHistory[historyIndex].map(c=>[...c]);
    clusters = clustersHistory[historyIndex] ? new Uint16Array(clustersHistory[historyIndex]) : (originalImageData ? assignClusters(originalImageData.data, extractedPalette) : null);
    applyPaletteToCanvas();
    renderExtractedPalette(); clearHighlight(); updateUndoRedoButtons();
  }
}
function updateUndoRedoButtons(){ undoColors.disabled = !(historyIndex > 0); redoColors.disabled = !(historyIndex < paletteHistory.length-1); }

/* -------------------------
  Apply palette (recolor canvas using clusters -> palette)
-------------------------*/
function applyPaletteToCanvas(){
  if (!originalImageData || !clusters || extractedPalette.length===0) return;
  const w = originalImageData.width, h = originalImageData.height;
  const newImageData = ctx.createImageData(w,h);
  const newData = newImageData.data;
  const od = originalImageData.data;
  for (let i=0,pid=0;i<od.length;i+=4,pid++){
    const ci = clusters[pid];
    if (ci < extractedPalette.length){
      const col = extractedPalette[ci];
      newData[i] = col[0]; newData[i+1] = col[1]; newData[i+2] = col[2]; newData[i+3] = od[i+3];
    } else {
      newData[i] = od[i]; newData[i+1] = od[i+1]; newData[i+2] = od[i+2]; newData[i+3] = od[i+3];
    }
  }
  // draw to main canvas sized to original resolution, then set display size separately
  canvas.width = w; canvas.height = h;
  ctx.putImageData(newImageData, 0, 0);
  // store updated "originalImageData" so future ops work on this new base
  originalImageData = newImageData;
  // update display scaling
  updateCanvasDisplaySize();
}

/* -------------------------
  Hue & Lightness operations
   - hueShiftDegrees: -180..180
   - lightnessDelta: -0.5..0.5 (applied in relative terms to L)
   - preserves near-perfect black/white
-------------------------*/
function applyHueLightnessToSelected(hueValue, lightValue){
  if (selectedGroup.size === 0) { alert('Select one or more palette colors (Ctrl/Cmd+click) first'); return; }
  saveToHistory();
  const targetH = ((parseFloat(hueValue) % 360) + 360) % 360;
  const targetL = Math.max(0, Math.min(100, parseFloat(lightValue))) / 100;

  // compute average lightness of the selected group (0..1)
  let totalL = 0, count = 0;
  for (const idx of selectedGroup){
    const c = extractedPalette[idx];
    if (!c) continue;
    const { l } = rgbToHsl(c[0], c[1], c[2]); // l is 0..1
    totalL += l;
    count++;
  }
  const avgL = count ? (totalL / count) : targetL;
  const delta = targetL - avgL; // preserve relative differences by applying delta

  // apply: preserve saturation, set hue to targetH, adjust lightness by delta per color
  for (let idx of Array.from(selectedGroup)){
    const c = extractedPalette[idx];
    if (!c) continue;
    const { h, s, l } = rgbToHsl(c[0], c[1], c[2]);
    // keep true black/white unchanged
    if (l < 0.03 || l > 0.97) continue;
    const newL = Math.min(1, Math.max(0, l + delta));
    const newRgb = hslToRgb(targetH / 360, s, newL);
    extractedPalette[idx] = [newRgb.r, newRgb.g, newRgb.b];
  }

  applyPaletteToCanvas();
  renderExtractedPalette();
  clearHighlight();
  updateStatus();
}

/* -------------------------
  Merge similar colors — grouping by RGB euclidean distance threshold
-------------------------*/
function calculateColorDistance(c1,c2){
  const dr=c1[0]-c2[0], dg=c1[1]-c2[1], db=c1[2]-c2[2];
  return Math.sqrt(dr*dr + dg*dg + db*db);
}

function mergeSimilarColors(){
  if (!extractedPalette || extractedPalette.length === 0) { alert('No palette yet'); return; }
  saveToHistory();
  const thresholdPercent = parseInt(mergeSlider.value);
  const maxDistance = Math.sqrt(255*255*3);
  const thresholdDistance = (thresholdPercent/100) * maxDistance;
  const colorMergeMap = {};
  const mergedColors = [];
  const used = new Set();
  for (let i=0;i<extractedPalette.length;i++){
    if (used.has(i)) continue;
    const group = [i]; let avg = [...extractedPalette[i]];
    for (let j=i+1;j<extractedPalette.length;j++){
      if (used.has(j)) continue;
      const d = calculateColorDistance(extractedPalette[i], extractedPalette[j]);
      if (d <= thresholdDistance){
        group.push(j);
        avg[0] += extractedPalette[j][0];
        avg[1] += extractedPalette[j][1];
        avg[2] += extractedPalette[j][2];
      }
    }
    if (group.length>1){
      avg[0] = Math.round(avg[0]/group.length);
      avg[1] = Math.round(avg[1]/group.length);
      avg[2] = Math.round(avg[2]/group.length);
    }
    const newIndex = mergedColors.length;
    mergedColors.push(avg);
    for (const old of group){ colorMergeMap[old]=newIndex; used.add(old); }
  }
  // fallback for any unmerged colors
  for (let i=0;i<extractedPalette.length;i++){
    if (!used.has(i)){
      colorMergeMap[i] = mergedColors.length;
      mergedColors.push([...extractedPalette[i]]);
    }
  }
  // remap clusters to new merged indices
  if (clusters){
    for (let i=0;i<clusters.length;i++){
      const old = clusters[i];
      clusters[i] = colorMergeMap[old] || 0;
    }
  }
  extractedPalette = mergedColors;
  applyPaletteToCanvas();
  renderExtractedPalette();
  clearHighlight();
}

/* -------------------------
  Load image handler (preserve original resolution)
-------------------------*/
fileInput.addEventListener('change', e=>{
  const f = e.target.files[0]; if (!f) return;
  const img = new Image();
  img.onload = ()=>{
    // set canvas to original image size
    originalCanvasWidth = img.width; originalCanvasHeight = img.height;
    canvas.width = originalCanvasWidth; canvas.height = originalCanvasHeight;
    // draw original image
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0, 0);
    // Preserve pristine data (deep copies) only on first load or when new file chosen
    originalLoadedImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    originalImageData = new ImageData(new Uint8ClampedArray(originalLoadedImageData.data), originalLoadedImageData.width, originalLoadedImageData.height);
    extractedPalette = extractDiverseColors(originalImageData.data, TARGET_PER_PALETTE);
    clusters = assignClusters(originalImageData.data, extractedPalette);
    originalPalette = extractedPalette.map(c=>[...c]);
    originalClusters = new Uint16Array(clusters);
    /* History initialization */
    paletteHistory = [extractedPalette.map(c=>[...c])];
    clustersHistory = [new Uint16Array(clusters)];
    historyIndex = 0;
    // set display styles (scale to container)
    updateCanvasDisplaySize();
    renderExtractedPalette();
    clearHighlight();
    selectedGroup = new Set();
    updateStatus();
    updateSlidersFromSelectedGroup();
    // show overlay if grid enabled
    // updateGrid(); // This function was removed
  };
  img.src = URL.createObjectURL(f);
});

/* -------------------------
  Update canvas display (scale down for viewing but keep internal resolution)
-------------------------*/
function updateCanvasDisplaySize(){
  if (!canvas.width || !canvas.height) return;
  const containerW = canvasContainer.clientWidth - 20;
  const containerH = Math.max(260, window.innerHeight * 0.6);
  let dw = canvas.width, dh = canvas.height;
  if (dw > containerW || dh > containerH){
    const scale = Math.min(containerW/dw, containerH/dh);
    dw = Math.round(dw * scale);
    dh = Math.round(dh * scale);
  }
  canvas.style.width = dw + 'px';
  canvas.style.height = dh + 'px';
  displayedWidth = dw; displayedHeight = dh;
  // reset viewport transform
  resetZoomAndPan();
  // recreate highlight overlay to match scaling
  if (highlightOverlay){ highlightOverlay.remove(); highlightOverlay = null; }
  updateOverlayPosition();
}

/* -------------------------
  Zoom & pan initialization
-------------------------*/
function updateViewportTransform(){
  const transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
  canvasViewport.style.transform = transform;
  if (highlightOverlay){ highlightOverlay.style.transform = `translate(-50%,-50%) ${transform}`; }
}

function resetZoomAndPan(){ zoomLevel=1; panX=0; panY=0; updateViewportTransform(); }

function zoomToPoint(mouseX, mouseY, zoomDelta){
  const rect = canvasContainer.getBoundingClientRect();
  const containerCenterX = rect.width/2, containerCenterY = rect.height/2;
  const mouseOffsetX = mouseX - rect.left - containerCenterX;
  const mouseOffsetY = mouseY - rect.top - containerCenterY;
  const oldZoom = zoomLevel;
  zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel*zoomDelta));
  const zoomRatio = zoomLevel/oldZoom;
  panX = mouseOffsetX - (mouseOffsetX - panX) * zoomRatio;
  panY = mouseOffsetY - (mouseOffsetY - panY) * zoomRatio;
  updateViewportTransform();
}

function initializeImageZoom(){
  canvasContainer.addEventListener('wheel', (e)=>{
    if (e.ctrlKey || e.metaKey) { /* allow browser zoom */ }
    e.preventDefault();
    const zoomDelta = e.deltaY < 0 ? 1.12 : 0.88;
    zoomToPoint(e.clientX, e.clientY, zoomDelta);
    setTimeout(()=>updateOverlayPosition(), 60);
  }, { passive:false });

  canvasContainer.addEventListener('mousedown', (e)=>{
    isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; canvasContainer.style.cursor='grabbing';
  });
  document.addEventListener('mousemove', (e)=>{
    if (!isDragging) return;
    const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY;
    panX += dx; panY += dy; lastMouseX = e.clientX; lastMouseY = e.clientY; updateViewportTransform();
    if (highlightOverlay) updateOverlayPosition();
  });
  document.addEventListener('mouseup', ()=>{ isDragging = false; canvasContainer.style.cursor='default'; });
  canvasContainer.addEventListener('dblclick', ()=> resetZoomAndPan());
  // touch pinch/drag omitted for brevity but can be added if needed
}
initializeImageZoom();

/* -------------------------
  Download processed image at original resolution
-------------------------*/
downloadButton.addEventListener('click', ()=> {
  if (!canvas || !originalCanvasWidth || !originalCanvasHeight) { alert('No image loaded'); return; }
  try {
    const dlCanvas = document.createElement('canvas'); dlCanvas.width = originalCanvasWidth; dlCanvas.height = originalCanvasHeight;
    const dlCtx = dlCanvas.getContext('2d', { alpha:true });
    // If originalImageData corresponds to current canvas, use it; else get current canvas pixels
    let dataToUse = originalImageData;
    try { dataToUse = ctx.getImageData(0,0, canvas.width, canvas.height); } catch(e){ dataToUse = originalImageData; }
    // If internal canvas is original resolution, use putImageData; else we have already been drawing originalImageData at internal resolution
    dlCtx.putImageData(dataToUse, 0, 0);
    dlCanvas.toBlob((blob)=> {
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
      a.href = URL.createObjectURL(blob);
      a.download = `sprite-color-shifted-${ts}.png`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(a.href), 1500);
    }, 'image/png', 1.0);
  } catch (err){
    console.error(err); alert('Failed to prepare download — try a smaller image for testing.');
  }
});

/* -------------------------
  Controls interactions
-------------------------*/
applyHueBtn.addEventListener('click', ()=>{
  const hue = parseInt(hueSliderEl.value);
  const light = parseInt(lightSliderEl.value);
  applyHueLightnessToSelected(hue, light);
});

mergeSlider.addEventListener('input', ()=>{ mergeValue.textContent = mergeSlider.value; });
applyMergeBtn.addEventListener('click', mergeSimilarColors);

undoColors.addEventListener('click', ()=> undo(1));
redoColors.addEventListener('click', ()=> redo(1));

resetAllBtn.addEventListener('click', ()=>{
  if (!originalLoadedImageData) return;
  if (!confirm('Restore original image, palette, and undo all merges & recolors?')) return;
  // Restore pixels
  canvas.width = originalLoadedImageData.width;
  canvas.height = originalLoadedImageData.height;
  ctx.putImageData(originalLoadedImageData,0,0);
  // Restore working image copy
  originalImageData = new ImageData(new Uint8ClampedArray(originalLoadedImageData.data), originalLoadedImageData.width, originalLoadedImageData.height);
  // Restore palette & clusters
  extractedPalette = originalPalette.map(c=>[...c]);
  clusters = new Uint16Array(originalClusters);
  // Reset selection & history
  selectedGroup.clear();
  paletteHistory = [extractedPalette.map(c=>[...c])];
  clustersHistory = [new Uint16Array(clusters)];
  historyIndex = 0;
  renderExtractedPalette();
  clearHighlight();
  updateUndoRedoButtons();
  updateStatus();
  updateSlidersFromSelectedGroup();
});

/* Center Image button (reset zoom & pan + recenter overlay) */
const centerBtn = document.getElementById('resetZoomPan');
centerBtn.addEventListener('click', ()=>{
  resetZoomAndPan();
  updateOverlayPosition();
});

/* Clear Selection button */
document.getElementById('clearSelection').addEventListener('click', ()=>{
  if (selectedGroup.size === 0) return;
  selectedGroup.clear();
  document.querySelectorAll('.swatch.grouped').forEach(s=>s.classList.remove('grouped'));
  clearHighlight();
  updateSlidersFromSelectedGroup(); // will not change (no selection) but keeps behavior consistent
});

/* -------------------------
  Arrow clickers
-------------------------*/
hueLeft.addEventListener('click', ()=> {
  let v = parseInt(hueSliderEl.value);
  v = (v - 1 + 361) % 361;
  hueSliderEl.value = v;
  hueSliderEl.dispatchEvent(new Event('input', {bubbles:true}));
});
hueRight.addEventListener('click', ()=> {
  let v = parseInt(hueSliderEl.value);
  v = (v + 1) % 361;
  hueSliderEl.value = v;
  hueSliderEl.dispatchEvent(new Event('input', {bubbles:true}));
});
lightLeft.addEventListener('click', ()=> {
  let v = parseInt(lightSliderEl.value);
  if (v > 0) { lightSliderEl.value = v-1; lightSliderEl.dispatchEvent(new Event('input', {bubbles:true})); }
});
lightRight.addEventListener('click', ()=> {
  let v = parseInt(lightSliderEl.value);
  if (v < 100) { lightSliderEl.value = v+1; lightSliderEl.dispatchEvent(new Event('input', {bubbles:true})); }
});

/* -------------------------
  Slider display functions
-------------------------*/
function updateHueDisplay(){
  hueValue.textContent = `${hueSliderEl.value}°`;
}

function updateLightDisplay(){
  lightValue.textContent = `${lightSliderEl.value}%`;
}

function updateHueGradientFromLightness(lightPct){
  // lightPct: 0..100 -> 0..1
  const L = Math.max(0, Math.min(1, lightPct/100));
  const stops = [];
  // sample every 12° to keep gradient size sane
  for (let deg=0; deg<=360; deg+=12){
    const rgb = hslToRgb(deg/360, 1, L);
    const pos = Math.round((deg/360)*100);
    stops.push(`rgb(${rgb.r},${rgb.g},${rgb.b}) ${pos}%`);
  }
  hueSliderEl.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
}

/* -------------------------
  Keep displays & gradient in sync
-------------------------*/
hueSliderEl.addEventListener('input', ()=> {
  updateHueDisplay();
});
lightSliderEl.addEventListener('input', ()=> {
  updateLightDisplay();
  updateHueGradientFromLightness(parseInt(lightSliderEl.value));
});

/* initialize visuals */
updateHueDisplay();
updateLightDisplay();
updateHueGradientFromLightness(parseInt(lightSliderEl.value));

/* -------------------------
  Group-aware slider calibration
  - circular average for hue, linear average for lightness
-------------------------*/
function averageHueLightnessOfSelected(){
  if (!selectedGroup || selectedGroup.size === 0) return null;
  let sinSum = 0, cosSum = 0;
  let totalL = 0, count = 0;
  for (const idx of selectedGroup){
    const c = extractedPalette[idx];
    if (!c) continue;
    const {h,l} = rgbToHsl(c[0], c[1], c[2]); // h 0..1, l 0..1
    const deg = h*360;
    const rad = deg * Math.PI / 180;
    sinSum += Math.sin(rad);
    cosSum += Math.cos(rad);
    totalL += l;
    count++;
  }
  if (count === 0) return null;
  const avgRad = Math.atan2(sinSum/count, cosSum/count);
  let avgDeg = (avgRad * 180 / Math.PI);
  if (avgDeg < 0) avgDeg += 360;
  const avgL = totalL / count; // 0..1
  return { hueDeg: avgDeg, lightPct: Math.round(avgL * 100) };
}

function updateSlidersFromSelectedGroup(){
  const avg = averageHueLightnessOfSelected();
  if (!avg) {
    // If no selection, reset sliders to default
    hueSliderEl.value = 180;
    lightSliderEl.value = 50;
  } else {
    // set hue slider to avg hue, set lightness slider to avg lightness percent
    hueSliderEl.value = Math.round(avg.hueDeg);
    lightSliderEl.value = Math.round(avg.lightPct);
  }
  // update visuals
  updateHueDisplay();
  updateLightDisplay();
  updateHueGradientFromLightness(parseInt(lightSliderEl.value));
}

/* -------------------------
  Call updateSlidersFromSelectedGroup when selection changes
  (inject into palette click logic)
-------------------------*/
/* ...existing code... */
// In the palette swatch click handler, after updating selectedGroup, call updateSlidersFromSelectedGroup()
// Example region replacement inside renderExtractedPalette click handler:
/*
      if (ev.ctrlKey || ev.metaKey){
        if (selectedGroup.has(i)){
          selectedGroup.delete(i);
        } else {
          selectedGroup.add(i);
        }
        document.querySelectorAll('.swatch.grouped').forEach(s=>s.classList.remove('grouped'));
        Array.from(selectedGroup).forEach(idx=>{
          const swatch = colorList.children[idx];
          if (swatch) swatch.classList.add('grouped');
        });
        updateStatus();
        updateSlidersFromSelectedGroup();    // <-- newly added
      } else {
        ...
      }
*/
/* ...existing code... */

/* -------------------------
  Apply using absolute hue & lightness
  - hueValue: 0..360, lightValue: 0..100
-------------------------*/
function applyHueLightnessToSelected(hueDeg, lightPct){
  if (selectedGroup.size === 0) { alert('Select one or more palette colors (Ctrl/Cmd+click) first'); return; }
  saveToHistory();
  const targetH = ((parseFloat(hueDeg) % 360) + 360) % 360;
  const targetL = Math.max(0, Math.min(100, parseFloat(lightPct))) / 100;
  for (let idx of Array.from(selectedGroup)){
    const c = extractedPalette[idx];
    if (!c) continue;
    const {h,s,l} = rgbToHsl(c[0], c[1], c[2]);
    // preserve near-black/white if wanted; otherwise set to targetL (we keep preserving extremes)
    if (l < 0.03 || l > 0.97) continue;
    const newRgb = hslToRgb(targetH/360, s, targetL);
    extractedPalette[idx] = [newRgb.r, newRgb.g, newRgb.b];
  }
  applyPaletteToCanvas();
  renderExtractedPalette();
  clearHighlight();
  updateStatus();
}

/* update apply button */
applyHueBtn.addEventListener('click', ()=>{
  applyHueLightnessToSelected(hueSliderEl.value, lightSliderEl.value);
});
</script>
</body>
</html>

